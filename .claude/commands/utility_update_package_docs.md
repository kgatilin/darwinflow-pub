Update package-level CLAUDE.md documentation for all packages in the project.

# Process Overview

This command regenerates package-level documentation by:
1. Generating high-level architecture documentation
2. Discovering all packages in the project
3. Creating CLAUDE.md files with generated docs + architectural guidance

# Step 1: Generate Architecture Index

First, regenerate the project architecture index:

```bash
go-arch-lint docs
```

This updates `@docs/arch-index.md` with current package structure.

# Step 2: Read Architecture Index

Read `docs/arch-index.md` to understand:
- All packages in the project
- Package dependencies
- Package layer assignments
- Architectural rules

# Step 3: Discover Packages

From the architecture index, identify all packages to document. Typically includes:
- `pkg/*` packages (public APIs and plugins)
- `internal/*` packages (application internals)
- `cmd/*` packages (entry points)

# Step 4: Generate Package Documentation

For each discovered package:

## 4a. Generate Base Documentation

Run go-arch-lint for the package:
```bash
go-arch-lint -format=package <package-path>
```

This provides:
- Exported API listing
- Dependencies
- File counts
- Type/function signatures

## 4b. Determine Package Role

Based on the package path and dependencies, determine its architectural role:

- **SDK packages** (`pkg/pluginsdk`) - Public contracts, zero internal dependencies
- **Domain packages** (`internal/domain`) - Business logic, no infrastructure dependencies
- **Infrastructure packages** (`internal/infra`) - Implements domain interfaces, handles I/O
- **Application packages** (`internal/app`) - Orchestration, service composition
- **UI packages** (`internal/app/tui`, `internal/app/web`) - User interface, thin presentation layer
- **Plugin packages** (`pkg/plugins/*`) - Plugin implementations, SDK-only dependencies
- **Entry packages** (`cmd/*`) - Main entry points, dependency wiring

## 4c. Create CLAUDE.md File

Create `<package-dir>/CLAUDE.md` with this structure:

```markdown
# Package: <name>

**Path**: `<package-path>`

**Role**: <1-line description based on layer>

---

## Quick Reference

- **Files**: <count from go-arch-lint>
- **Exports**: <count from go-arch-lint>
- **Dependencies**: <local dependencies from go-arch-lint>
- **Layer**: <architectural layer>

---

## Generated Documentation

<Full output from go-arch-lint -format=package>

---

## Architectural Principles

### What MUST Be Here

✅ <Based on package role and layer>
✅ <3-5 items describing appropriate content>
✅ <Use layer-specific guidance>

### What MUST NOT Be Here

❌ <Based on architectural rules>
❌ <3-5 items describing what belongs elsewhere>
❌ <Reference correct location>

### Critical Rules

1. <Dependency rules from architecture>
2. <Layer-specific constraints>
3. <Design principles for this layer>
4. <Testing requirements>
5. <Other important rules>

---

## <Layer-Specific Sections>

<Add 2-4 sections based on package role>

For SDK packages:
- Interface design guidelines
- Capability model
- Plugin development workflow

For Domain packages:
- Business logic patterns
- Repository pattern
- Value objects and entities

For Infrastructure packages:
- Implementation patterns
- Error mapping
- External service integration

For Application packages:
- Service composition
- Dependency injection
- Use case implementation

For UI packages:
- UI framework patterns (Bubble Tea, web framework, etc.)
- State management
- Async operations

For Plugin packages:
- Plugin implementation guide
- Entity/command patterns
- SDK integration

For Entry packages:
- Bootstrap process
- Command routing
- Dependency wiring

---

## Testing Strategy

<Layer-appropriate testing guidance>

---

## Files

<File list from go-arch-lint>

---

*Generated by `go-arch-lint -format=package <package-path>`*
```

# Layer-Specific Guidance Rules

## For Public SDK Packages
- Emphasize: No internal dependencies, backward compatibility
- Focus: Interface contracts, capability model
- Avoid: Implementation details, framework knowledge

## For Domain Packages
- Emphasize: Framework-agnostic, pure business logic
- Focus: Interfaces, entities, business rules
- Avoid: Infrastructure, I/O, framework coupling

## For Infrastructure Packages
- Emphasize: Implement domain interfaces
- Focus: Repository pattern, external services, I/O
- Avoid: Business logic, domain rules

## For Application Packages
- Emphasize: Orchestration, not logic
- Focus: Service composition, use cases, coordination
- Avoid: Business rules, infrastructure details

## For UI Packages
- Emphasize: Thin presentation layer
- Focus: Framework patterns, user interaction, rendering
- Avoid: Business logic, data access

## For Plugin Packages
- Emphasize: Plugin-specific types, SDK-only imports
- Focus: Entity implementation, commands, events
- Avoid: Framework coupling, internal dependencies

## For Entry Packages
- Emphasize: Thin wiring layer
- Focus: Bootstrap, routing, dependency injection
- Avoid: Business logic, heavy computation

# Documentation Size Target

- **Generated docs**: ~100-200 lines (from go-arch-lint)
- **Architectural guidance**: ~100-150 lines
- **Total per file**: ~200-350 lines

Keep it concise, actionable, and focused on architectural boundaries.

# Execution Steps

1. Run `go-arch-lint docs` to regenerate architecture index
2. Read `docs/arch-index.md` to discover packages
3. For each package in parallel:
   - Run `go-arch-lint -format=package <path>`
   - Determine package layer/role from path and dependencies
   - Create/update `<package-dir>/CLAUDE.md`
   - Apply layer-specific guidance
4. Verify all CLAUDE.md files created
5. Report completion

# Key Principles

- **Process-oriented**: Discover packages dynamically, don't hardcode
- **Layer-aware**: Apply guidance based on architectural role
- **Consistency**: Use same structure for all packages
- **Conciseness**: Keep focused on "what goes where"
- **Actionable**: Clear rules for what belongs in each package
