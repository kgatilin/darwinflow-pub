package cli

import (
	"context"
	"fmt"

	"github.com/kgatilin/darwinflow-pub/pkg/plugins/task_manager/application"
	"github.com/kgatilin/darwinflow-pub/pkg/plugins/task_manager/application/dto"
	"github.com/kgatilin/darwinflow-pub/pkg/plugins/task_manager/domain/entities"
	"github.com/kgatilin/darwinflow-pub/pkg/pluginsdk"
)

// ============================================================================
// IterationCreateCommandAdapter - Adapts CLI to CreateIterationCommand use case
// ============================================================================

type IterationCreateCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	project     string
	name        string
	goal        string
	deliverable string
}

func (c *IterationCreateCommandAdapter) GetName() string {
	return "iteration create"
}

func (c *IterationCreateCommandAdapter) GetDescription() string {
	return "Create a new iteration"
}

func (c *IterationCreateCommandAdapter) GetUsage() string {
	return "dw task-manager iteration create --name <name> --goal <goal> --deliverable <desc>"
}

func (c *IterationCreateCommandAdapter) GetHelp() string {
	return `Creates a new iteration with auto-incremented number.

Flags:
  --name <name>            Iteration name (required)
  --goal <goal>            Iteration goal (required)
  --deliverable <desc>     Deliverable description (required)
  --project <name>         Project name (optional)`
}

func (c *IterationCreateCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse flags
	for i := 0; i < len(args); i++ {
		switch args[i] {
		case "--project":
			if i+1 < len(args) {
				c.project = args[i+1]
				i++
			}
		case "--name":
			if i+1 < len(args) {
				c.name = args[i+1]
				i++
			}
		case "--goal":
			if i+1 < len(args) {
				c.goal = args[i+1]
				i++
			}
		case "--deliverable":
			if i+1 < len(args) {
				c.deliverable = args[i+1]
				i++
			}
		}
	}

	// Validate required flags
	if c.name == "" {
		return fmt.Errorf("--name is required")
	}
	if c.goal == "" {
		return fmt.Errorf("--goal is required")
	}
	if c.deliverable == "" {
		return fmt.Errorf("--deliverable is required")
	}


	// Create DTO (iteration number is auto-generated by service)
	input := dto.CreateIterationDTO{
		Name:        c.name,
		Goal:        c.goal,
		Deliverable: c.deliverable,
	}

	// Execute via application service
	iteration, err := c.IterationService.CreateIteration(ctx, input)
	if err != nil {
		return fmt.Errorf("failed to create iteration: %w", err)
	}

	// Format output
	out := cmdCtx.GetStdout()
	fmt.Fprintf(out, "Iteration created successfully\n")
	fmt.Fprintf(out, "  Number:      %d\n", iteration.Number)
	fmt.Fprintf(out, "  Name:        %s\n", iteration.Name)
	fmt.Fprintf(out, "  Goal:        %s\n", iteration.Goal)
	fmt.Fprintf(out, "  Deliverable: %s\n", iteration.Deliverable)
	fmt.Fprintf(out, "  Status:      %s\n", iteration.Status)

	return nil
}

// ============================================================================
// IterationUpdateCommandAdapter - Adapts CLI to UpdateIterationCommand use case
// ============================================================================

type IterationUpdateCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	project     string
	number      int
	name        *string
	goal        *string
	deliverable *string
}

func (c *IterationUpdateCommandAdapter) GetName() string {
	return "iteration update"
}

func (c *IterationUpdateCommandAdapter) GetDescription() string {
	return "Update an existing iteration"
}

func (c *IterationUpdateCommandAdapter) GetUsage() string {
	return "dw task-manager iteration update <iteration-number> [options]"
}

func (c *IterationUpdateCommandAdapter) GetHelp() string {
	return `Updates an existing iteration's fields.

Flags:
  --name <name>            New iteration name
  --goal <goal>            New iteration goal
  --deliverable <desc>     New deliverable description
  --project <name>         Project name (optional)`
}

func (c *IterationUpdateCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}
	fmt.Sscanf(args[0], "%d", &c.number)
	args = args[1:]

	// Parse flags
	for i := 0; i < len(args); i++ {
		switch args[i] {
		case "--project":
			if i+1 < len(args) {
				c.project = args[i+1]
				i++
			}
		case "--name":
			if i+1 < len(args) {
				val := args[i+1]
				c.name = &val
				i++
			}
		case "--goal":
			if i+1 < len(args) {
				val := args[i+1]
				c.goal = &val
				i++
			}
		case "--deliverable":
			if i+1 < len(args) {
				val := args[i+1]
				c.deliverable = &val
				i++
			}
		}
	}

	// Validate at least one field
	if c.name == nil && c.goal == nil && c.deliverable == nil {
		return fmt.Errorf("at least one field must be specified to update")
	}

	// Create DTO
	input := dto.UpdateIterationDTO{
		Number:      c.number,
		Name:        c.name,
		Goal:        c.goal,
		Deliverable: c.deliverable,
	}

	// Execute via application service
	iteration, err := c.IterationService.UpdateIteration(ctx, input)
	if err != nil {
		return fmt.Errorf("failed to update iteration: %w", err)
	}

	// Format output
	out := cmdCtx.GetStdout()
	fmt.Fprintf(out, "Iteration updated successfully\n")
	fmt.Fprintf(out, "  Number:      %d\n", iteration.Number)
	fmt.Fprintf(out, "  Name:        %s\n", iteration.Name)
	fmt.Fprintf(out, "  Goal:        %s\n", iteration.Goal)
	fmt.Fprintf(out, "  Deliverable: %s\n", iteration.Deliverable)
	fmt.Fprintf(out, "  Status:      %s\n", iteration.Status)

	return nil
}

// ============================================================================
// IterationStartCommandAdapter - Adapts CLI to StartIterationCommand use case
// ============================================================================

type IterationStartCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	project string
	number  int
}

func (c *IterationStartCommandAdapter) GetName() string {
	return "iteration start"
}

func (c *IterationStartCommandAdapter) GetDescription() string {
	return "Start an iteration (set as current)"
}

func (c *IterationStartCommandAdapter) GetUsage() string {
	return "dw task-manager iteration start <iteration-number>"
}

func (c *IterationStartCommandAdapter) GetHelp() string {
	return `Sets an iteration as the current active iteration.

Only one iteration can be current at a time.`
}

func (c *IterationStartCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}
	fmt.Sscanf(args[0], "%d", &c.number)
	args = args[1:]

	// Parse flags
	for i := 0; i < len(args); i++ {
		switch args[i] {
		case "--project":
			if i+1 < len(args) {
				c.project = args[i+1]
				i++
			}
		}
	}

	// Execute via application service
	if err := c.IterationService.StartIteration(ctx, c.number); err != nil {
		return fmt.Errorf("failed to start iteration: %w", err)
	}

	// Get updated iteration for output
	iteration, err := c.IterationService.GetIteration(ctx, c.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration: %w", err)
	}

	// Format output
	out := cmdCtx.GetStdout()
	fmt.Fprintf(out, "Iteration %d started successfully\n", iteration.Number)
	fmt.Fprintf(out, "  Status: %s\n", iteration.Status)

	return nil
}

// ============================================================================
// IterationCompleteCommandAdapter - Adapts CLI to CompleteIterationCommand use case
// ============================================================================

type IterationCompleteCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	project string
	number  int
}

func (c *IterationCompleteCommandAdapter) GetName() string {
	return "iteration complete"
}

func (c *IterationCompleteCommandAdapter) GetDescription() string {
	return "Mark an iteration as complete"
}

func (c *IterationCompleteCommandAdapter) GetUsage() string {
	return "dw task-manager iteration complete <iteration-number>"
}

func (c *IterationCompleteCommandAdapter) GetHelp() string {
	return `Marks an iteration as complete.`
}

func (c *IterationCompleteCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}
	fmt.Sscanf(args[0], "%d", &c.number)
	args = args[1:]

	// Parse flags
	for i := 0; i < len(args); i++ {
		switch args[i] {
		case "--project":
			if i+1 < len(args) {
				c.project = args[i+1]
				i++
			}
		}
	}

	// Execute via application service
	if err := c.IterationService.CompleteIteration(ctx, c.number); err != nil {
		return fmt.Errorf("failed to complete iteration: %w", err)
	}

	// Get updated iteration for output
	iteration, err := c.IterationService.GetIteration(ctx, c.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration: %w", err)
	}

	// Format output
	out := cmdCtx.GetStdout()
	fmt.Fprintf(out, "Iteration %d completed successfully\n", iteration.Number)
	fmt.Fprintf(out, "  Status: %s\n", iteration.Status)

	return nil
}

// ============================================================================
// IterationListCommandAdapter - Adapts CLI to ListIterations query use case
// ============================================================================

type IterationListCommandAdapter struct {
	IterationService *application.IterationApplicationService
}

func (a *IterationListCommandAdapter) GetName() string {
	return "iteration list"
}

func (a *IterationListCommandAdapter) GetDescription() string {
	return "List all iterations"
}

func (a *IterationListCommandAdapter) GetUsage() string {
	return "dw task-manager iteration list"
}

func (a *IterationListCommandAdapter) GetHelp() string {
	return `Lists all iterations in the project.

Displays iteration number, name, goal, status, task count, and timestamps.

Examples:
  dw task-manager iteration list

Notes:
  - Iterations are displayed in order by number
  - Status values: planned, current, complete
  - Use 'iteration show <number>' for detailed information`
}

func (a *IterationListCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Query application service
	iterations, err := a.IterationService.ListIterations(ctx)
	if err != nil {
		return fmt.Errorf("failed to list iterations: %w", err)
	}

	out := cmdCtx.GetStdout()

	if len(iterations) == 0 {
		fmt.Fprintf(out, "No iterations found.\n")
		return nil
	}

	// Display header
	fmt.Fprintf(out, "%-3s %-30s %-20s %-10s %-5s\n",
		"#", "Name", "Goal", "Status", "Tasks")
	fmt.Fprintf(out, "%s %s %s %s %s\n",
		"---", "------------------------------", "--------------------", "----------", "-----")

	// Display iterations
	for _, iter := range iterations {
		name := iter.Name
		if len(name) > 30 {
			name = name[:27] + "..."
		}
		goal := iter.Goal
		if len(goal) > 20 {
			goal = goal[:17] + "..."
		}

		fmt.Fprintf(out, "%-3d %-30s %-20s %-10s %-5d\n",
			iter.Number,
			name,
			goal,
			iter.Status,
			len(iter.TaskIDs))
	}

	return nil
}

// ============================================================================
// IterationShowCommandAdapter - Adapts CLI to GetIteration + GetIterationTasks query
// ============================================================================

type IterationShowCommandAdapter struct {
	IterationService    *application.IterationApplicationService
	DocumentService     *application.DocumentApplicationService

	// CLI flags
	number int
}

func (a *IterationShowCommandAdapter) GetName() string {
	return "iteration show"
}

func (a *IterationShowCommandAdapter) GetDescription() string {
	return "Display a specific iteration"
}

func (a *IterationShowCommandAdapter) GetUsage() string {
	return "dw task-manager iteration show <number>"
}

func (a *IterationShowCommandAdapter) GetHelp() string {
	return `Displays detailed information about a specific iteration.

Shows the iteration's properties, timestamps, and all associated tasks.

Arguments:
  <number>  Iteration number (required)

Examples:
  dw task-manager iteration show 1

Notes:
  - Run 'dw task-manager iteration list' to see all iteration numbers
  - Use 'iteration add-task' to add tasks to an iteration`
}

func (a *IterationShowCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}

	var number int
	_, err := fmt.Sscanf(args[0], "%d", &number)
	if err != nil {
		return fmt.Errorf("invalid iteration number: %w", err)
	}
	a.number = number

	// Query application service
	iteration, err := a.IterationService.GetIteration(ctx, a.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration: %w", err)
	}

	// Get tasks in iteration
	tasks, err := a.IterationService.GetIterationTasks(ctx, a.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration tasks: %w", err)
	}

	out := cmdCtx.GetStdout()

	// Display iteration details
	fmt.Fprintf(out, "Iteration %d: %s\n", iteration.Number, iteration.Name)
	fmt.Fprintf(out, "  Status:      %s\n", iteration.Status)
	fmt.Fprintf(out, "  Goal:        %s\n", iteration.Goal)
	if iteration.Deliverable != "" {
		fmt.Fprintf(out, "  Deliverable: %s\n", iteration.Deliverable)
	}
	fmt.Fprintf(out, "  Tasks:       %d\n", len(tasks))
	fmt.Fprintf(out, "  Rank:        %d\n", iteration.Rank)
	fmt.Fprintf(out, "  Created:     %s\n", iteration.CreatedAt.Format("2006-01-02 15:04:05"))
	fmt.Fprintf(out, "  Updated:     %s\n", iteration.UpdatedAt.Format("2006-01-02 15:04:05"))

	// Display tasks if any
	if len(tasks) > 0 {
		fmt.Fprintf(out, "\nTasks:\n")
		for _, task := range tasks {
			fmt.Fprintf(out, "  - %s (%s)\n", task.ID, task.Status)
		}
	}

	// Display attached documents
	iterationNum := a.number
	documents, err := a.DocumentService.ListDocuments(ctx, nil, &iterationNum, nil)
	if err != nil {
		// Log error but don't fail the command - documents are optional
		fmt.Fprintf(out, "\nWarning: failed to load documents: %v\n", err)
	} else {
		fmt.Fprintf(out, "\nAttached Documents:\n")
		if len(documents) == 0 {
			fmt.Fprintf(out, "  (none)\n")
		} else {
			// Display table header
			fmt.Fprintf(out, "  %-20s %-30s %-15s %-10s\n",
				"ID", "Title", "Type", "Status")
			fmt.Fprintf(out, "  %s %s %s %s\n",
				"--------------------", "------------------------------", "---------------", "----------")

			// Display documents
			for _, doc := range documents {
				title := doc.Title
				if len(title) > 30 {
					title = title[:27] + "..."
				}
				fmt.Fprintf(out, "  %-20s %-30s %-15s %-10s\n",
					doc.ID,
					title,
					doc.Type,
					doc.Status)
			}
		}
	}

	return nil
}

// ============================================================================
// IterationCurrentCommandAdapter - Adapts CLI to GetCurrentIteration query
// ============================================================================

type IterationCurrentCommandAdapter struct {
	IterationService *application.IterationApplicationService
	DocumentService  *application.DocumentApplicationService
}

func (a *IterationCurrentCommandAdapter) GetName() string {
	return "iteration current"
}

func (a *IterationCurrentCommandAdapter) GetDescription() string {
	return "Display the current iteration"
}

func (a *IterationCurrentCommandAdapter) GetUsage() string {
	return "dw task-manager iteration current"
}

func (a *IterationCurrentCommandAdapter) GetHelp() string {
	return `Displays the iteration with status 'current'.

Only one iteration can be current at a time.

Examples:
  dw task-manager iteration current

Notes:
  - Use 'iteration start <number>' to set a current iteration
  - Use 'iteration list' to see all iterations`
}

func (a *IterationCurrentCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Query application service
	result, err := a.IterationService.GetCurrentIteration(ctx)
	if err != nil {
		return fmt.Errorf("failed to get current iteration: %w", err)
	}

	out := cmdCtx.GetStdout()

	// Check if no iterations found at all
	if result.Iteration == nil {
		fmt.Fprintf(out, "%s\n", result.FallbackMsg)
		return nil
	}

	// Cast iteration to entity (we know it's *entities.IterationEntity)
	iteration, ok := result.Iteration.(*entities.IterationEntity)
	if !ok {
		return fmt.Errorf("unexpected iteration type")
	}

	// Display fallback message if applicable
	if result.IsFallback {
		fmt.Fprintf(out, "%s\n\n", result.FallbackMsg)
	}

	// Get tasks in iteration
	tasks, err := a.IterationService.GetIterationTasks(ctx, iteration.Number)
	if err != nil {
		return fmt.Errorf("failed to get iteration tasks: %w", err)
	}

	// Display iteration details
	if result.IsFallback {
		fmt.Fprintf(out, "Iteration: %d - %s\n", iteration.Number, iteration.Name)
	} else {
		fmt.Fprintf(out, "Current Iteration: %d - %s\n", iteration.Number, iteration.Name)
	}
	fmt.Fprintf(out, "  Status:      %s\n", iteration.Status)
	fmt.Fprintf(out, "  Goal:        %s\n", iteration.Goal)
	if iteration.Deliverable != "" {
		fmt.Fprintf(out, "  Deliverable: %s\n", iteration.Deliverable)
	}
	fmt.Fprintf(out, "  Tasks:       %d\n", len(tasks))

	// Display tasks if any
	if len(tasks) > 0 {
		fmt.Fprintf(out, "\nTasks:\n")
		for _, task := range tasks {
			fmt.Fprintf(out, "  - %s (%s)\n", task.ID, task.Status)
		}
	}

	// Display attached documents
	documents, err := a.DocumentService.ListDocuments(ctx, nil, &iteration.Number, nil)
	if err != nil {
		// Log error but don't fail the command - documents are optional
		fmt.Fprintf(out, "\nWarning: failed to load documents: %v\n", err)
	} else {
		fmt.Fprintf(out, "\nAttached Documents:\n")
		if len(documents) == 0 {
			fmt.Fprintf(out, "  (none)\n")
		} else {
			// Display table header
			fmt.Fprintf(out, "  %-20s %-30s %-15s %-10s\n",
				"ID", "Title", "Type", "Status")
			fmt.Fprintf(out, "  %s %s %s %s\n",
				"--------------------", "------------------------------", "---------------", "----------")

			// Display documents
			for _, doc := range documents {
				title := doc.Title
				if len(title) > 30 {
					title = title[:27] + "..."
				}
				fmt.Fprintf(out, "  %-20s %-30s %-15s %-10s\n",
					doc.ID,
					title,
					doc.Type,
					doc.Status)
			}
		}
	}

	return nil
}

// ============================================================================
// IterationDeleteCommandAdapter - Adapts CLI to DeleteIteration command
// ============================================================================

type IterationDeleteCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	number int
}

func (a *IterationDeleteCommandAdapter) GetName() string {
	return "iteration delete"
}

func (a *IterationDeleteCommandAdapter) GetDescription() string {
	return "Delete an iteration"
}

func (a *IterationDeleteCommandAdapter) GetUsage() string {
	return "dw task-manager iteration delete <number>"
}

func (a *IterationDeleteCommandAdapter) GetHelp() string {
	return `Deletes an iteration from the project.

Arguments:
  <number>  Iteration number (required)

Examples:
  dw task-manager iteration delete 1

Notes:
  - This will remove the iteration and its task associations
  - Use 'iteration list' to see all iteration numbers`
}

func (a *IterationDeleteCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}

	var number int
	_, err := fmt.Sscanf(args[0], "%d", &number)
	if err != nil {
		return fmt.Errorf("invalid iteration number: %w", err)
	}
	a.number = number

	// Execute via application service
	if err := a.IterationService.DeleteIteration(ctx, a.number); err != nil {
		return fmt.Errorf("failed to delete iteration: %w", err)
	}

	fmt.Fprintf(cmdCtx.GetStdout(), "Iteration %d deleted successfully\n", a.number)
	return nil
}

// ============================================================================
// IterationAddTaskCommandAdapter - Adapts CLI to AddTask command
// ============================================================================

type IterationAddTaskCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	number  int
	taskIDs []string
}

func (a *IterationAddTaskCommandAdapter) GetName() string {
	return "iteration add-task"
}

func (a *IterationAddTaskCommandAdapter) GetDescription() string {
	return "Add task(s) to an iteration"
}

func (a *IterationAddTaskCommandAdapter) GetUsage() string {
	return "dw task-manager iteration add-task <iteration> <task-id> [<task-id>...]"
}

func (a *IterationAddTaskCommandAdapter) GetHelp() string {
	return `Adds one or more tasks to an iteration.

Arguments:
  <iteration>  Iteration number (required)
  <task-id>    Task ID(s) to add (required, can specify multiple)

Examples:
  # Add single task
  dw task-manager iteration add-task 1 TM-task-1

  # Add multiple tasks
  dw task-manager iteration add-task 1 TM-task-1 TM-task-2 TM-task-3

Notes:
  - Task must exist before adding to iteration
  - Same task cannot be added to iteration multiple times`
}

func (a *IterationAddTaskCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) < 2 {
		return fmt.Errorf("iteration number and at least one task ID are required")
	}

	var number int
	_, err := fmt.Sscanf(args[0], "%d", &number)
	if err != nil {
		return fmt.Errorf("invalid iteration number: %w", err)
	}
	a.number = number
	a.taskIDs = args[1:]

	out := cmdCtx.GetStdout()
	successCount := 0
	var lastErr error

	// Add each task
	for _, taskID := range a.taskIDs {
		if err := a.IterationService.AddTask(ctx, a.number, taskID); err != nil {
			fmt.Fprintf(out, "Failed to add task %s: %v\n", taskID, err)
			lastErr = err
		} else {
			fmt.Fprintf(out, "Added task %s to iteration %d\n", taskID, a.number)
			successCount++
		}
	}

	if successCount > 0 {
		fmt.Fprintf(out, "Successfully added %d task(s)\n", successCount)
	}

	if lastErr != nil && successCount == 0 {
		return lastErr
	}

	return nil
}

// ============================================================================
// IterationRemoveTaskCommandAdapter - Adapts CLI to RemoveTask command
// ============================================================================

type IterationRemoveTaskCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	number  int
	taskIDs []string
}

func (a *IterationRemoveTaskCommandAdapter) GetName() string {
	return "iteration remove-task"
}

func (a *IterationRemoveTaskCommandAdapter) GetDescription() string {
	return "Remove task(s) from an iteration"
}

func (a *IterationRemoveTaskCommandAdapter) GetUsage() string {
	return "dw task-manager iteration remove-task <iteration> <task-id> [<task-id>...]"
}

func (a *IterationRemoveTaskCommandAdapter) GetHelp() string {
	return `Removes one or more tasks from an iteration.

Arguments:
  <iteration>  Iteration number (required)
  <task-id>    Task ID(s) to remove (required, can specify multiple)

Examples:
  # Remove single task
  dw task-manager iteration remove-task 1 TM-task-1

  # Remove multiple tasks
  dw task-manager iteration remove-task 1 TM-task-1 TM-task-2

Notes:
  - Task must be associated with iteration before removal
  - Task itself is not deleted, only the iteration association`
}

func (a *IterationRemoveTaskCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) < 2 {
		return fmt.Errorf("iteration number and at least one task ID are required")
	}

	var number int
	_, err := fmt.Sscanf(args[0], "%d", &number)
	if err != nil {
		return fmt.Errorf("invalid iteration number: %w", err)
	}
	a.number = number
	a.taskIDs = args[1:]

	out := cmdCtx.GetStdout()
	successCount := 0
	var lastErr error

	// Remove each task
	for _, taskID := range a.taskIDs {
		if err := a.IterationService.RemoveTask(ctx, a.number, taskID); err != nil {
			fmt.Fprintf(out, "Failed to remove task %s: %v\n", taskID, err)
			lastErr = err
		} else {
			fmt.Fprintf(out, "Removed task %s from iteration %d\n", taskID, a.number)
			successCount++
		}
	}

	if successCount > 0 {
		fmt.Fprintf(out, "Successfully removed %d task(s)\n", successCount)
	}

	if lastErr != nil && successCount == 0 {
		return lastErr
	}

	return nil
}

// ============================================================================
// IterationViewCommandAdapter - Adapts CLI to GetIteration query with markdown format
// ============================================================================

type IterationViewCommandAdapter struct {
	IterationService *application.IterationApplicationService

	// CLI flags
	number int
}

func (a *IterationViewCommandAdapter) GetName() string {
	return "iteration view"
}

func (a *IterationViewCommandAdapter) GetDescription() string {
	return "Display iteration details in markdown format"
}

func (a *IterationViewCommandAdapter) GetUsage() string {
	return "dw task-manager iteration view <number>"
}

func (a *IterationViewCommandAdapter) GetHelp() string {
	return `Displays iteration details in markdown format.

Arguments:
  <number>  Iteration number (required)

Examples:
  dw task-manager iteration view 1

Notes:
  - Output is suitable for documentation and sharing
  - Includes all iteration metadata and task details`
}

func (a *IterationViewCommandAdapter) Execute(ctx context.Context, cmdCtx pluginsdk.CommandContext, args []string) error {
	// Parse iteration number
	if len(args) == 0 {
		return fmt.Errorf("iteration number is required")
	}

	var number int
	_, err := fmt.Sscanf(args[0], "%d", &number)
	if err != nil {
		return fmt.Errorf("invalid iteration number: %w", err)
	}
	a.number = number

	// Query application service
	iteration, err := a.IterationService.GetIteration(ctx, a.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration: %w", err)
	}

	// Get tasks in iteration
	tasks, err := a.IterationService.GetIterationTasks(ctx, a.number)
	if err != nil {
		return fmt.Errorf("failed to get iteration tasks: %w", err)
	}

	out := cmdCtx.GetStdout()

	// Output markdown format
	fmt.Fprintf(out, "# Iteration %d: %s\n\n", iteration.Number, iteration.Name)
	fmt.Fprintf(out, "**Status**: %s\n\n", iteration.Status)
	fmt.Fprintf(out, "**Goal**: %s\n\n", iteration.Goal)

	if iteration.Deliverable != "" {
		fmt.Fprintf(out, "**Deliverable**: %s\n\n", iteration.Deliverable)
	}

	fmt.Fprintf(out, "## Details\n\n")
	fmt.Fprintf(out, "- **Number**: %d\n", iteration.Number)
	fmt.Fprintf(out, "- **Rank**: %d\n", iteration.Rank)
	fmt.Fprintf(out, "- **Created**: %s\n", iteration.CreatedAt.Format("2006-01-02 15:04:05"))
	fmt.Fprintf(out, "- **Updated**: %s\n", iteration.UpdatedAt.Format("2006-01-02 15:04:05"))

	if iteration.StartedAt != nil {
		fmt.Fprintf(out, "- **Started**: %s\n", iteration.StartedAt.Format("2006-01-02 15:04:05"))
	}
	if iteration.CompletedAt != nil {
		fmt.Fprintf(out, "- **Completed**: %s\n", iteration.CompletedAt.Format("2006-01-02 15:04:05"))
	}

	// Display tasks if any
	if len(tasks) > 0 {
		fmt.Fprintf(out, "\n## Tasks (%d)\n\n", len(tasks))
		for _, task := range tasks {
			fmt.Fprintf(out, "- **%s** (%s)\n", task.ID, task.Status)
			if task.Title != "" {
				fmt.Fprintf(out, "  - Title: %s\n", task.Title)
			}
			if task.Description != "" {
				fmt.Fprintf(out, "  - Description: %s\n", task.Description)
			}
		}
	} else {
		fmt.Fprintf(out, "\n## Tasks\n\nNo tasks in this iteration.\n")
	}

	return nil
}
